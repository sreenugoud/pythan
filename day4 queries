
use mph;

CREATE TABLE Customers (
    customer_id INT PRIMARY KEY,
    customer_name VARCHAR(50),
    customer_email VARCHAR(50)
);


INSERT INTO Customers VALUES
(1, 'Asha', 'asha@gmail.com'),
(2, 'Malar', 'malar@gmail.com'),
(3, 'Manish', 'manish@gmail.com'),
(4, 'Divya', 'divya@gmail.com'),
(5, 'Girish', 'girish@gmail.com'),
(6, 'Deepak', 'deepak@gmail.com');


CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(50),
    product_price DECIMAL(10, 2)
);

-- Insert sample data into Product table
INSERT INTO Products VALUES
(101, 'Laptop', 50000.99),
(102, 'Smartphone', 15000.99),
(103, 'Headphones',1000.99),
(104, 'Tablet', 12000.99),
(105, 'Wireless Mouse', 800.99);


CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    product_id INT,
    quantity INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id),
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
);

INSERT INTO Orders VALUES
(1, 1, 101, 2, '2024-01-01'),
(2, 2, 102, 1, '2024-01-02'),
(3, 3, 103, 3, '2024-01-03'),
(4, 1, 104, 1, '2024-01-04'),
(5, 2, 105, 2, '2024-01-05'),
(6, 4, 101, 1, '2024-01-06'),
(7, 5, 102, 3, '2024-01-07');

select * from customers;
select * from products;
select * from Orders;

---------------------------------------------------
SELECT 
    order_id, customer_name, product_name
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON p.product_id = o.product_id;
    
 -- Retrive the total number of orders for each products
 
 select p.product_name,count(o.order_id) from orders o join products p on o.product_id= p.product_id group by p.product_name ;
    
 --  calculate the toatal revenue generated by each customer
 select customer_name ,sum(product_price*quantity) as totalrevenue from customers c join orders o on c.customer_id=o.customer_id  join products p on o.product_id=p.product_id group by customer_name;
--------------------
-- find the customer who have generatted the highest revenue
SELECT 
    customer_name, SUM(product_price * quantity) AS totalrevenue
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON o.product_id = p.product_id
GROUP BY customer_name
LIMIT 1;
-- find the top 3 customer who have generatted the highest revenue
SELECT 
    customer_name, SUM(product_price * quantity) AS totalrevenue
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON o.product_id = p.product_id
GROUP BY customer_name
LIMIT 3;
-- find the customer name whospent the least
SELECT 
    customer_name, SUM(product_price * quantity) AS totalrevenue
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON o.product_id = p.product_id
GROUP BY customer_name order by totalrevenue limit 1 ;

-- find the customer name who have not placed any order
select c.customer_name from customers c left join orders o on c.customer_id=o.customer_id where o.order_id is null  ;

-- find the customer names who ordered laptop

SELECT 
   c.customer_name,p.Product_name
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON o.product_id = p.product_id
 where p.Product_name='laptop';
 
 -- get the product name ,quantity,and order date for orders made after a specific date(2024-01-03)
 SELECT 
  o.quantity,p.Product_name,o.order_date
FROM
    orders o
        JOIN
    products p ON o.product_id = p.product_id
 where o.order_date > 2024-01-03 ;
 
 -- retrieve the customer names who have ordered products prices higher than the 45000
SELECT 
   c.customer_id,c.customer_name,p.product_price
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    products p ON o.product_id = p.product_id
 where product_price >45000;
 
 ----------------------
 -- views -- virtual table
 -- data taken from the under lying base tables 
create view myemp as select * from emp;
drop view myemp;
create view myemp as select empno,ename,deptno from emp;
create or replace view myemp as select empno,ename,sal,deptno from emp;
select * from myemp;
desc myemp;
--------------
-- INDEX : for faster retrieval
alter table emp drop index myindex;
create index myindex on emp(ename,job);
select * from emp;
desc emp;

---------------------------
-- PL/SQL -- Procedural language /structured language

-- it has a block structure


stored procedure -- block which will execute bu does not 
Return Anything
modes -- 3 modes -- 
'in ,out,inout '
 function -- block which will eecute But WILL RETURN something 
 modes in function 
 '-- only one mode -- in '
 
 triggers -- block executed after an event (insert,update,delete)

DELIMITER //
create procedure proc1(in custid int,out cname varchar(20))
begin
  select customer_name into cname from customers where customer_id=custid;
  select count(*) from customers ;
end//
DELIMITER ;

call proc1(1,@cname);
select @cname;
drop procedure proc1;

delimiter //
create procedure proc2 (inout timer  int, in num int)
begin
set timer = timer +num;
END//
delimiter ;
set @timer=1;
call proc2(@timer,1);
call proc2(@timer,5);
select @timer;

--------- functions 

delimiter $$
create function myfunc (custname varchar(20),cid int)
returns varchar(20)
deterministic
begin 
select customer_name into custname from customers where customer_id =cid;
return custname;
end $$
delimiter ;

select myfunc(@custname,1);
select myfunc(@custname,2);
select myfunc(@custname,3);


DELIMITER //
create procedure proc3(in eid int,out empname varchar(20) , out  salary int )
begin
  select ename,sal into empname,salary from emp where empno=eid;
end//
DELIMITER ;
call proc3(7499,@empname,@salary);
select @empname,@salary;
drop procedure proc3;

delimiter //
create procedure proc4(in eid int)
begin
declare empname varchar(20);
declare salary int;
   SELECT ENAME,SAL INTO EMPNAME,salary from emp where empno=eid ;
   select empname,salary;
END //
delimiter ;
call proc4(7499);

-- procedure update salary details in employee table

delimiter //
create procedure proc5(inout salary  int, in updatedsal int, in empid int )
begin
set salary = salary +updatedsal;
END//
delimiter ;
call proc5(@salary,1);
select @salary;
drop procedure proc5;

delimiter //
create procedure proc6(cname varchar(20) )
begin
delete  from emp where ename=cname;
END//
delimiter ;

call proc6('blake');
drop procedure proc6;

-- procedure to calculate toala salary in a department

delimiter //
create procedure proc7(in deptn int, out salary int)
begin
select sum(e.sal) from emp e join dept d on e.deptno=d.deptno where d.deptno=deptn;
END//
delimiter ;
call proc7(20,@salary);
select @salary;

-- function to retrive employee name using employee id
-- 1) 	Function to retrieve employee name  using employee id
delimiter $$
create function myfunc (custname varchar(20),cid int)
returns varchar(20)
deterministic
begin 
select customer_name into custname from customers where customer_id =cid;
return custname;
end $$
delimiter ;

select myfunc(@custname,1);
select myfunc(@custname,2);
select myfunc(@custname,3);

-- 2)Function to retrieve department name using department id
delimiter $$
create function myfunc1 (jobrole varchar(20),deptno1 int)
returns varchar(20)
deterministic
begin 
select dname into jobrole from dept where deptno =deptno1;
return jobrole;
end $$
delimiter ;

select myfunc1(@jobrole,20);
select myfunc1(@jobrole,10);
drop function myfunc1;
-- 3) Function to caluclate the average salary in department 30
delimiter $$
create function myfunc2 (salary decimal (10,2), deptnoz int)
returns decimal(10,2)
deterministic
begin 
select avg(sal)  into salary from emp where deptno = deptnoz ;
return salary ;
end $$
delimiter ;
select myfunc2(@salary,30);
 drop function myfunc2;
-- json
delimiter $$
create function getemployeeinfo (emid int)
returns json
deterministic
begin
	declare emp_info json;
    select json_object('empname',ename ,'ejob',job)
    into emp_info from emp where empno=empid;
    return emp_info;
end $$
delimiter ;


-- 4) Function to retrieve employees salary details whose salary is greater than 2500
delimiter $$
create function myfunc3 (salary2 int,enames varchar(30) )
returns int
deterministic
begin 
select sal,ename into salary2,enames from emp where sal >2500;
return salary2;
end $$
delimiter ;
drop function myfunc3;
select myfunc3(@salary2);

delimiter $$
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 < 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;
delimiter ;

call doiterate(4);
select(@x);
  
  
  -- = new old -- pseudo codes
Trigger : procedures called automatically based on an event

CREATE
    [DEFINER = user]
    TRIGGER [IF NOT EXISTS] trigger_name
    trigger_time trigger_event
    ON tbl_name FOR EACH ROW
    [trigger_order]
    trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

trigger_order: { FOLLOWS | PRECEDES } other_trigger_name

2 types of trigger:
1) Statement Level trigger  -- the trigger will be fired only once for the whole TABLE
2) Row Level trigger -- the trigger will be fired for each and every row in the table
						(FOR EACH ROW)


---------------------------------------------------------
alter table products add stock int;

update products 
set stock = CASE 
    WHEN product_id=101 THEN 30
    WHEN product_id=102 THEN 20
    WHEN product_id=103 THEN 40
    WHEN product_id=104 THEN 10
    WHEN product_id=105 THEN 80
	ELSE stock
END
where product_id IN (101,102,103,104,105);

 
delimiter //
create trigger afterorderinsert
after insert on orders
for each row
begin
   update products set stock = stock - new.quantity
   where product_id = new.product_id;

end//
delimiter ;

insert into orders values(8,4,103,5,'2024-03-05');






